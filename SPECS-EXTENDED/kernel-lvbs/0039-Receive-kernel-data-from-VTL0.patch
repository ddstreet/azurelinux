From 6b36e5ad0d68e590dea4d53eacbd7b0b292aef32 Mon Sep 17 00:00:00 2001
From: "Madhavan T. Venkataraman" <madvenka@microsoft.com>
Date: Wed, 10 Jul 2024 12:22:08 -0500
Subject: [PATCH 39/68] Receive kernel data from VTL0

Implement a new hypercall to receive kernel data from VTL0.

For starters, receive module certificates from VTL0. Create a trusted
keyring from the module certificates.

In the future, this will be used by VTL1 to verify the signature of a
module when the module is loaded in VTL0.

iSigned-off-by: Madhavan T. Venkataraman <madvenka@microsoft.com>
---
 drivers/hv/mshv_vsm_vtl1.c | 78 ++++++++++++++++++++++++++++++++++++++
 1 file changed, 78 insertions(+)

diff --git a/drivers/hv/mshv_vsm_vtl1.c b/drivers/hv/mshv_vsm_vtl1.c
index 8b16a8cd526d..8594c3d6f0b1 100644
--- a/drivers/hv/mshv_vsm_vtl1.c
+++ b/drivers/hv/mshv_vsm_vtl1.c
@@ -13,6 +13,8 @@
 #include <linux/fs.h>
 #include <linux/delay.h>
 #include <linux/interrupt.h>
+#include <linux/key.h>
+#include <keys/system_keyring.h>
 #include <linux/heki.h>
 #include <linux/sort.h>
 #include <linux/mem_attr.h>
@@ -188,6 +190,11 @@ struct hv_vsm_per_cpu {
 
 static DEFINE_PER_CPU(struct hv_vsm_per_cpu, vsm_per_cpu);
 
+struct vtl0 {
+	struct heki_mem mem[HEKI_KDATA_MAX];
+	struct key *trusted_keys;
+} vtl0;
+
 struct hv_input_modify_vtl_protection_mask {
 	u64 partition_id;
 	u32 map_flags;
@@ -918,6 +925,72 @@ static int mshv_vsm_lock_regs(void)
 	return ret;
 }
 
+int x509_load_certificate_list(const u8 cert_list[],
+			       const unsigned long list_size,
+			       const struct key *keyring);
+
+static int mshv_vsm_create_trusted_keys(void)
+{
+	struct heki_mem *mem = &vtl0.mem[HEKI_MODULE_CERTS];
+	void *certs = mem->va;
+	unsigned long certs_size = mem->size;
+	int ret = 0;
+
+	if (vtl0.trusted_keys) {
+		/* Can only load this once. */
+		pr_warn("%s: Certificates already loaded\n", __func__);
+		ret = -EINVAL;
+		goto unmap;
+	}
+
+	vtl0.trusted_keys =
+		keyring_alloc(".guest_trusted_keys",
+			      GLOBAL_ROOT_UID, GLOBAL_ROOT_GID, current_cred(),
+			      ((KEY_POS_ALL & ~KEY_POS_SETATTR) |
+			      KEY_USR_VIEW | KEY_USR_READ | KEY_USR_SEARCH),
+			      KEY_ALLOC_NOT_IN_QUOTA,
+			      NULL, NULL);
+	if (!vtl0.trusted_keys) {
+		pr_warn("%s: Could not allocate trusted keyring\n", __func__);
+		ret = -ENOMEM;
+		goto unmap;
+	}
+
+	/* Populate a trusted keyring with VTL0 module certificates. */
+	ret = x509_load_certificate_list(certs, certs_size, vtl0.trusted_keys);
+	if (ret) {
+		pr_warn("%s: Can't populate trusted keyring\n", __func__);
+		key_put(vtl0.trusted_keys);
+		vtl0.trusted_keys = NULL;
+	} else {
+		pr_debug("%s: Created trusted keys\n", __func__);
+	}
+
+unmap:
+	vsm_unmap(mem);
+	return ret;
+}
+
+static int mshv_vsm_load_kdata(u64 pa, unsigned long nranges)
+{
+	struct heki_range *ranges;
+	int ret;
+
+	ranges = __vsm_read_ranges(pa, nranges, true);
+	if (!ranges)
+		return -ENOMEM;
+
+	ret = vsm_map_all(ranges, nranges, vtl0.mem, HEKI_KDATA_MAX);
+	if (ret)
+		goto free_ranges;
+
+	ret =  mshv_vsm_create_trusted_keys();
+
+free_ranges:
+	vfree(ranges);
+	return ret;
+}
+
 /********************** Boot Secondary CPUs **********************/
 static int mshv_vsm_boot_aps(unsigned int cpu_online_mask_pfn,
 							unsigned int boot_signal_pfn)
@@ -1195,6 +1268,11 @@ static void mshv_vsm_handle_entry(struct hv_vtlcall_param *_vtl_params)
 		if (!vtl0_end_of_boot)
 			status = mshv_vsm_protect_memory(_vtl_params->a1, _vtl_params->a2);
 		break;
+	case VSM_VTL_CALL_FUNC_ID_LOAD_KDATA:
+		pr_debug("%s : VSM_LOAD_KDATA\n", __func__);
+		if (!vtl0_end_of_boot)
+			status = mshv_vsm_load_kdata(_vtl_params->a1, _vtl_params->a2);
+		break;
 	default:
 		pr_err("%s: Wrong Command:0x%llx sent into VTL1\n", __func__, _vtl_params->a0);
 		break;
-- 
2.43.0

